!function(c){function s(s){for(var n,a,e=s[0],l=s[1],t=s[2],p=0,r=[];p<e.length;p++)a=e[p],i[a]&&r.push(i[a][0]),i[a]=0;for(n in l)Object.prototype.hasOwnProperty.call(l,n)&&(c[n]=l[n]);for(h&&h(s);r.length;)r.shift()();return _.push.apply(_,t||[]),o()}function o(){for(var s,n=0;n<_.length;n++){for(var a=_[n],e=!0,l=1;l<a.length;l++){var t=a[l];0!==i[t]&&(e=!1)}e&&(_.splice(n--,1),s=p(p.s=a[0]))}return s}var a={},i={1:0},_=[];function p(s){if(a[s])return a[s].exports;var n=a[s]={i:s,l:!1,exports:{}};return c[s].call(n.exports,n,n.exports,p),n.l=!0,n.exports}p.m=c,p.c=a,p.d=function(s,n,a){p.o(s,n)||Object.defineProperty(s,n,{enumerable:!0,get:a})},p.r=function(s){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(s,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(s,"__esModule",{value:!0})},p.t=function(n,s){if(1&s&&(n=p(n)),8&s)return n;if(4&s&&"object"==typeof n&&n&&n.__esModule)return n;var a=Object.create(null);if(p.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:n}),2&s&&"string"!=typeof n)for(var e in n)p.d(a,e,function(s){return n[s]}.bind(null,e));return a},p.n=function(s){var n=s&&s.__esModule?function(){return s.default}:function(){return s};return p.d(n,"a",n),n},p.o=function(s,n){return Object.prototype.hasOwnProperty.call(s,n)},p.p="./";var n=window.webpackJsonp=window.webpackJsonp||[],e=n.push.bind(n);n.push=s,n=n.slice();for(var l=0;l<n.length;l++)s(n[l]);var h=e;_.push([430,2,0]),o()}({0:function(s,n,a){s.exports=a(36)(0)},1:function(s,n,a){s.exports=a(36)(1)},134:function(s,n,a){s.exports=a(36)(4)},135:function(s,n,a){s.exports=a(36)(42)},136:function(s,n,a){s.exports=a(36)(56)},201:function(s,n,a){s.exports=a(36)(46)},35:function(s,n,a){s.exports=a(36)(2)},36:function(s,n){s.exports=lib_3eaabf2e},381:function(s,n,a){s.exports=a(36)(23)},413:function(module,__webpack_exports__,__webpack_require__){"use strict";(function(module){var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(1),react__WEBPACK_IMPORTED_MODULE_0___default=__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__),react_router_dom__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(136),containers_Main__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(414),_createClass=function(s,n,a){return n&&oa(s.prototype,n),a&&oa(s,a),s},wa;function oa(s,n){for(var a=0;a<n.length;a++){var e=n[a];e.enumerable=e.enumerable||!1,e.configurable=!0,"value"in e&&(e.writable=!0),Object.defineProperty(s,e.key,e)}}function _classCallCheck(s,n){if(!(s instanceof n))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(s,n){if(!s)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?s:n}function _inherits(s,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);s.prototype=Object.create(n&&n.prototype,{constructor:{value:s,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(s,n):s.__proto__=n)}wa=__webpack_require__(18).enterModule,wa&&wa(module);var RootComponent=function(_React$Component){function RootComponent(){return _classCallCheck(this,RootComponent),_possibleConstructorReturn(this,(RootComponent.__proto__||Object.getPrototypeOf(RootComponent)).apply(this,arguments))}return _inherits(RootComponent,_React$Component),_createClass(RootComponent,[{key:"render",value:function(){return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_1__.HashRouter,null,react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_1__.Switch,null,react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_1__.Route,{path:"/",exact:!0,render:function(s){return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(containers_Main__WEBPACK_IMPORTED_MODULE_2__.a,s)}})))}},{key:"__reactstandin__regenerateByEval",value:function __reactstandin__regenerateByEval(key,code){this[key]=eval(code)}}]),RootComponent}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component),_default=RootComponent,Ga,Ha;__webpack_exports__.a=_default,Ga=__webpack_require__(18).default,Ha=__webpack_require__(18).leaveModule,Ga&&(Ga.register(RootComponent,"RootComponent","/Users/mac/Desktop/projects/Lets-Read/app/Router/index.jsx"),Ga.register(_default,"default","/Users/mac/Desktop/projects/Lets-Read/app/Router/index.jsx"),Ha(module))}).call(this,__webpack_require__(63)(module))},414:function(module,__webpack_exports__,__webpack_require__){"use strict";(function(module){__webpack_require__.d(__webpack_exports__,"a",function(){return Main});var antd_lib_spin_style_css__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(638),antd_lib_spin_style_css__WEBPACK_IMPORTED_MODULE_0___default=__webpack_require__.n(antd_lib_spin_style_css__WEBPACK_IMPORTED_MODULE_0__),antd_lib_spin__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(426),antd_lib_spin__WEBPACK_IMPORTED_MODULE_1___default=__webpack_require__.n(antd_lib_spin__WEBPACK_IMPORTED_MODULE_1__),antd_lib_row_style_css__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(640),antd_lib_row_style_css__WEBPACK_IMPORTED_MODULE_2___default=__webpack_require__.n(antd_lib_row_style_css__WEBPACK_IMPORTED_MODULE_2__),antd_lib_row__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(427),antd_lib_row__WEBPACK_IMPORTED_MODULE_3___default=__webpack_require__.n(antd_lib_row__WEBPACK_IMPORTED_MODULE_3__),antd_lib_col_style_css__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(641),antd_lib_col_style_css__WEBPACK_IMPORTED_MODULE_4___default=__webpack_require__.n(antd_lib_col_style_css__WEBPACK_IMPORTED_MODULE_4__),antd_lib_col__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(139),antd_lib_col__WEBPACK_IMPORTED_MODULE_5___default=__webpack_require__.n(antd_lib_col__WEBPACK_IMPORTED_MODULE_5__),antd_lib_empty_style_css__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__(366),antd_lib_empty_style_css__WEBPACK_IMPORTED_MODULE_6___default=__webpack_require__.n(antd_lib_empty_style_css__WEBPACK_IMPORTED_MODULE_6__),antd_lib_empty__WEBPACK_IMPORTED_MODULE_7__=__webpack_require__(198),antd_lib_empty__WEBPACK_IMPORTED_MODULE_7___default=__webpack_require__.n(antd_lib_empty__WEBPACK_IMPORTED_MODULE_7__),antd_lib_icon_style_css__WEBPACK_IMPORTED_MODULE_8__=__webpack_require__(367),antd_lib_icon_style_css__WEBPACK_IMPORTED_MODULE_8___default=__webpack_require__.n(antd_lib_icon_style_css__WEBPACK_IMPORTED_MODULE_8__),antd_lib_icon__WEBPACK_IMPORTED_MODULE_9__=__webpack_require__(32),antd_lib_icon__WEBPACK_IMPORTED_MODULE_9___default=__webpack_require__.n(antd_lib_icon__WEBPACK_IMPORTED_MODULE_9__),react__WEBPACK_IMPORTED_MODULE_10__=__webpack_require__(1),react__WEBPACK_IMPORTED_MODULE_10___default=__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_10__),for_editor__WEBPACK_IMPORTED_MODULE_11__=__webpack_require__(415),for_editor__WEBPACK_IMPORTED_MODULE_11___default=__webpack_require__.n(for_editor__WEBPACK_IMPORTED_MODULE_11__),components__WEBPACK_IMPORTED_MODULE_12__=__webpack_require__(416),_readList__WEBPACK_IMPORTED_MODULE_13__=__webpack_require__(424),_index_scss__WEBPACK_IMPORTED_MODULE_14__=__webpack_require__(425),_index_scss__WEBPACK_IMPORTED_MODULE_14___default=__webpack_require__.n(_index_scss__WEBPACK_IMPORTED_MODULE_14__),_createClass=function(s,n,a){return n&&Ia(s.prototype,n),a&&Ia(s,a),s},Qa;function Ia(s,n){for(var a=0;a<n.length;a++){var e=n[a];e.enumerable=e.enumerable||!1,e.configurable=!0,"value"in e&&(e.writable=!0),Object.defineProperty(s,e.key,e)}}function _classCallCheck(s,n){if(!(s instanceof n))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(s,n){if(!s)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?s:n}function _inherits(s,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);s.prototype=Object.create(n&&n.prototype,{constructor:{value:s,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(s,n):s.__proto__=n)}Qa=__webpack_require__(18).enterModule,Qa&&Qa(module);var toolbar={h1:!1,h2:!1,h3:!1,h4:!1,img:!1,link:!1,code:!1,preview:!1,expand:!0,undo:!1,redo:!1,save:!1,subfield:!1},Main=function(_React$Component){function Main(){var s,n,a;_classCallCheck(this,Main);for(var e=arguments.length,l=Array(e),t=0;t<e;t++)l[t]=arguments[t];return(n=a=_possibleConstructorReturn(this,(s=Main.__proto__||Object.getPrototypeOf(Main)).call.apply(s,[this].concat(l)))).state={value:"",selectData:{},expand:!0,spinning:!1},a.handleChange=function(s){a.setState({value:s})},a.handleSelect=function(s){a.setState({selectData:s})},a.renderIframe=function(s){var n=s.link;return n?react__WEBPACK_IMPORTED_MODULE_10___default.a.createElement("iframe",{src:n,width:"100%",height:"100%"}):react__WEBPACK_IMPORTED_MODULE_10___default.a.createElement(antd_lib_empty__WEBPACK_IMPORTED_MODULE_7___default.a,{image:react__WEBPACK_IMPORTED_MODULE_10___default.a.createElement(antd_lib_icon__WEBPACK_IMPORTED_MODULE_9___default.a,{type:"smile",theme:"twoTone"}),description:"请选择一篇文章"})},a.handleOpen=function(s){var n=s.link;n&&window.open(n)},a.handleShrink=function(){a.setState({expand:!1})},a.handleExpand=function(){a.setState({expand:!0})},_possibleConstructorReturn(a,n)}return _inherits(Main,_React$Component),_createClass(Main,[{key:"render",value:function(){var s=this.state,n=s.selectData,a=s.expand,e=s.spinning,l=n.link,t=n.md;return react__WEBPACK_IMPORTED_MODULE_10___default.a.createElement(antd_lib_spin__WEBPACK_IMPORTED_MODULE_1___default.a,{spinning:e},react__WEBPACK_IMPORTED_MODULE_10___default.a.createElement(antd_lib_row__WEBPACK_IMPORTED_MODULE_3___default.a,{className:_index_scss__WEBPACK_IMPORTED_MODULE_14___default.a.root},react__WEBPACK_IMPORTED_MODULE_10___default.a.createElement(antd_lib_col__WEBPACK_IMPORTED_MODULE_5___default.a,{span:a?3:1},react__WEBPACK_IMPORTED_MODULE_10___default.a.createElement(components__WEBPACK_IMPORTED_MODULE_12__.a,{treeData:_readList__WEBPACK_IMPORTED_MODULE_13__.a,rightable:!0,onOpen:this.handleOpen,onSelect:this.handleSelect}),a?react__WEBPACK_IMPORTED_MODULE_10___default.a.createElement("span",{className:"expand",onClick:this.handleShrink},"<"):react__WEBPACK_IMPORTED_MODULE_10___default.a.createElement("span",{className:"expand",onClick:this.handleExpand},">")),react__WEBPACK_IMPORTED_MODULE_10___default.a.createElement(antd_lib_col__WEBPACK_IMPORTED_MODULE_5___default.a,{span:a?11:13},this.renderIframe(n)),react__WEBPACK_IMPORTED_MODULE_10___default.a.createElement(antd_lib_col__WEBPACK_IMPORTED_MODULE_5___default.a,{span:10},l?react__WEBPACK_IMPORTED_MODULE_10___default.a.createElement(for_editor__WEBPACK_IMPORTED_MODULE_11___default.a,{preview:!0,toolbar:toolbar,value:__webpack_require__(842)("./"+t).default,className:"editor"}):null)))}},{key:"__reactstandin__regenerateByEval",value:function __reactstandin__regenerateByEval(key,code){this[key]=eval(code)}}]),Main}(react__WEBPACK_IMPORTED_MODULE_10___default.a.Component),pb,qb;pb=__webpack_require__(18).default,qb=__webpack_require__(18).leaveModule,pb&&(pb.register(toolbar,"toolbar","/Users/mac/Desktop/projects/Lets-Read/app/containers/Main/index.jsx"),pb.register(Main,"Main","/Users/mac/Desktop/projects/Lets-Read/app/containers/Main/index.jsx"),qb(module))}).call(this,__webpack_require__(63)(module))},424:function(s,o,i){"use strict";(function(s){i.d(o,"a",function(){return c});var n,a=i(14),e=i.n(a);(n=i(18).enterModule)&&n(s);function l(s,n){return s.forEach(function(s){s.children?(n.push(e.a.omit(s,"children")),l(s.children,n)):n.push(s)}),n}var t,p,r=[{id:"1",name:"js",disabledContext:!0,pId:"1",children:[{id:"1-1",name:"react-router「前端进阶」彻底弄懂前端路由",pId:"1",contextMenuKeys:["open"],link:"https://juejin.im/post/5d2d19ccf265da1b7f29b05f",md:"read-1-1.md"}]},{id:"2",name:"css",disabledContext:!0,pId:"2",children:[{id:"2-1",name:"CSS 变量教程",pId:"2",contextMenuKeys:["open"],link:"https://www.ruanyifeng.com/blog/2017/05/css-variables.html",md:"read-2-1.md"}]},{id:"3",name:"性能方面",disabledContext:!0,pId:"3",children:[{id:"3-1",name:"「中高级前端」高性能渲染十万条数据",pId:"3",contextMenuKeys:["open"],link:"https://juejin.im/post/5d76f469f265da039a28aff7",md:"read-3-1.md"},{id:"3-2",name:"diff算法",pId:"3",contextMenuKeys:["open"],link:"https://www.jianshu.com/p/398e63dc1969",md:"read-3-2.md"}]},{id:"4",name:"设计模式",disabledContext:!0,pId:"4",children:[{id:"4-1",name:"函数组合",pId:"4",contextMenuKeys:["open"],link:"https://juejin.im/post/5d50bfebf265da03cb122b6f",md:"read-4-1.md"}]},{id:"5",name:"node",disabledContext:!0,pId:"5"}],c=l(r,[]);t=i(18).default,p=i(18).leaveModule,t&&(t.register(r,"list","/Users/mac/Desktop/projects/Lets-Read/app/containers/Main/readList.js"),t.register(l,"buildData","/Users/mac/Desktop/projects/Lets-Read/app/containers/Main/readList.js"),t.register(c,"readList","/Users/mac/Desktop/projects/Lets-Read/app/containers/Main/readList.js"),p(s))}).call(this,i(63)(s))},425:function(s,n,a){s.exports={root:"root-23a6csI5"}},430:function(s,n,a){a(431),s.exports=a(633)},633:function(s,n,f){"use strict";f.r(n),function(s){f(634);var n,a=f(428),e=f.n(a),l=f(1),t=f.n(l),p=f(8),r=f.n(p),c=f(429),o=f.n(c),i=f(134),_=f(18),h=f(2),d=f.n(h),u=(f(167),f(413));(n=f(18).enterModule)&&n(s),d.a.locale("zh-cn"),f(848),f(849),Object(i.useStrict)(!0);function j(s){r.a.render(t.a.createElement(_.AppContainer,null,t.a.createElement(e.a,{locale:o.a},t.a.createElement(s,null))),document.getElementById("app"))}var m,g;window.onload=function(){j(u.a)},m=f(18).default,g=f(18).leaveModule,m&&(m.register(j,"render","/Users/mac/Desktop/projects/Lets-Read/app/index.js"),g(s))}.call(this,f(63)(s))},637:function(s,n,a){var e={"./af":240,"./af.js":240,"./ar":241,"./ar-dz":242,"./ar-dz.js":242,"./ar-kw":243,"./ar-kw.js":243,"./ar-ly":244,"./ar-ly.js":244,"./ar-ma":245,"./ar-ma.js":245,"./ar-sa":246,"./ar-sa.js":246,"./ar-tn":247,"./ar-tn.js":247,"./ar.js":241,"./az":248,"./az.js":248,"./be":249,"./be.js":249,"./bg":250,"./bg.js":250,"./bm":251,"./bm.js":251,"./bn":252,"./bn.js":252,"./bo":253,"./bo.js":253,"./br":254,"./br.js":254,"./bs":255,"./bs.js":255,"./ca":256,"./ca.js":256,"./cs":257,"./cs.js":257,"./cv":258,"./cv.js":258,"./cy":259,"./cy.js":259,"./da":260,"./da.js":260,"./de":261,"./de-at":262,"./de-at.js":262,"./de-ch":263,"./de-ch.js":263,"./de.js":261,"./dv":264,"./dv.js":264,"./el":265,"./el.js":265,"./en-SG":266,"./en-SG.js":266,"./en-au":267,"./en-au.js":267,"./en-ca":268,"./en-ca.js":268,"./en-gb":269,"./en-gb.js":269,"./en-ie":270,"./en-ie.js":270,"./en-il":271,"./en-il.js":271,"./en-nz":272,"./en-nz.js":272,"./eo":273,"./eo.js":273,"./es":274,"./es-do":275,"./es-do.js":275,"./es-us":276,"./es-us.js":276,"./es.js":274,"./et":277,"./et.js":277,"./eu":278,"./eu.js":278,"./fa":279,"./fa.js":279,"./fi":280,"./fi.js":280,"./fo":281,"./fo.js":281,"./fr":282,"./fr-ca":283,"./fr-ca.js":283,"./fr-ch":284,"./fr-ch.js":284,"./fr.js":282,"./fy":285,"./fy.js":285,"./ga":286,"./ga.js":286,"./gd":287,"./gd.js":287,"./gl":288,"./gl.js":288,"./gom-latn":289,"./gom-latn.js":289,"./gu":290,"./gu.js":290,"./he":291,"./he.js":291,"./hi":292,"./hi.js":292,"./hr":293,"./hr.js":293,"./hu":294,"./hu.js":294,"./hy-am":295,"./hy-am.js":295,"./id":296,"./id.js":296,"./is":297,"./is.js":297,"./it":298,"./it-ch":299,"./it-ch.js":299,"./it.js":298,"./ja":300,"./ja.js":300,"./jv":301,"./jv.js":301,"./ka":302,"./ka.js":302,"./kk":303,"./kk.js":303,"./km":304,"./km.js":304,"./kn":305,"./kn.js":305,"./ko":306,"./ko.js":306,"./ku":307,"./ku.js":307,"./ky":308,"./ky.js":308,"./lb":309,"./lb.js":309,"./lo":310,"./lo.js":310,"./lt":311,"./lt.js":311,"./lv":312,"./lv.js":312,"./me":313,"./me.js":313,"./mi":314,"./mi.js":314,"./mk":315,"./mk.js":315,"./ml":316,"./ml.js":316,"./mn":317,"./mn.js":317,"./mr":318,"./mr.js":318,"./ms":319,"./ms-my":320,"./ms-my.js":320,"./ms.js":319,"./mt":321,"./mt.js":321,"./my":322,"./my.js":322,"./nb":323,"./nb.js":323,"./ne":324,"./ne.js":324,"./nl":325,"./nl-be":326,"./nl-be.js":326,"./nl.js":325,"./nn":327,"./nn.js":327,"./pa-in":328,"./pa-in.js":328,"./pl":329,"./pl.js":329,"./pt":330,"./pt-br":331,"./pt-br.js":331,"./pt.js":330,"./ro":332,"./ro.js":332,"./ru":333,"./ru.js":333,"./sd":334,"./sd.js":334,"./se":335,"./se.js":335,"./si":336,"./si.js":336,"./sk":337,"./sk.js":337,"./sl":338,"./sl.js":338,"./sq":339,"./sq.js":339,"./sr":340,"./sr-cyrl":341,"./sr-cyrl.js":341,"./sr.js":340,"./ss":342,"./ss.js":342,"./sv":343,"./sv.js":343,"./sw":344,"./sw.js":344,"./ta":345,"./ta.js":345,"./te":346,"./te.js":346,"./tet":347,"./tet.js":347,"./tg":348,"./tg.js":348,"./th":349,"./th.js":349,"./tl-ph":350,"./tl-ph.js":350,"./tlh":351,"./tlh.js":351,"./tr":352,"./tr.js":352,"./tzl":353,"./tzl.js":353,"./tzm":354,"./tzm-latn":355,"./tzm-latn.js":355,"./tzm.js":354,"./ug-cn":356,"./ug-cn.js":356,"./uk":357,"./uk.js":357,"./ur":358,"./ur.js":358,"./uz":359,"./uz-latn":360,"./uz-latn.js":360,"./uz.js":359,"./vi":361,"./vi.js":361,"./x-pseudo":362,"./x-pseudo.js":362,"./yo":363,"./yo.js":363,"./zh-cn":167,"./zh-cn.js":167,"./zh-hk":364,"./zh-hk.js":364,"./zh-tw":365,"./zh-tw.js":365};function l(s){var n=t(s);return a(n)}function t(s){var n=e[s];if(n+1)return n;var a=new Error("Cannot find module '"+s+"'");throw a.code="MODULE_NOT_FOUND",a}l.keys=function(){return Object.keys(e)},l.resolve=t,(s.exports=l).id=637},718:function(s,n,a){s.exports=a(36)(24)},719:function(s,n,a){s.exports=a(36)(45)},776:function(s,n,a){s.exports=a(36)(25)},8:function(s,n,a){s.exports=a(36)(11)},842:function(s,n,a){var e={"./read-1-1.md":843,"./read-2-1.md":844,"./read-3-1.md":845,"./read-3-2.md":846,"./read-4-1.md":847};function l(s){var n=t(s);return a(n)}function t(s){var n=e[s];if(n+1)return n;var a=new Error("Cannot find module '"+s+"'");throw a.code="MODULE_NOT_FOUND",a}l.keys=function(){return Object.keys(e)},l.resolve=t,(s.exports=l).id=842},843:function(s,n,a){"use strict";a.r(n),n.default='<h2 id="什么是前端路由">什么是前端路由</h2>\n<p>简单的说，就是在保证只有一个 HTML 页面，且与用户交互时不刷新和跳转页面的同时，为 SPA 中的每个视图展示形式匹配一个特殊的 url。在刷新、前进、后退和SEO时均通过这个特殊的 url 来实现。</p>\n<p>为实现这一目标，我们需要做到以下二点：</p>\n<ol>\n<li><p>改变 url 且不让浏览器像服务器发送请求；</p>\n</li>\n<li><p>可以监听到 url 的变化</p>\n</li>\n</ol>\n<p>目前有两种模式，分别是 <strong>hash 模式和 history 模式</strong></p>\n<h3 id="hash模式">hash模式</h3>\n<p>这里的 hash 就是指 url 后的 # 号以及后面的字符。比如说 &quot;<a href="http://www.baidu.com/#hashhash&quot;">www.baidu.com/#hashhash&quot;</a> ，其中 &quot;#hashhash&quot; 就是我们期望的 hash 值。</p>\n<p>由于 hash 值的变化 <code>不会导致浏览器像服务器发送请求</code>, 而且 hash 的改变会触发 <code>hashchange</code>事件，浏览器的前进后退也能对其进行控制，所以在 H5 的 history 模式出现之前，基本都是使用 hash 模式来实现前端路由。</p>\n<ul>\n<li><strong><em>手动实现hash路由</em></strong></li>\n</ul>\n<pre><code class="language-js"><span class="hljs-keyword">class</span> HashRouter {\n    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>){\n        <span class="hljs-comment">// 初始化路由</span>\n        <span class="hljs-keyword">this</span>.routers = {};\n\n        <span class="hljs-comment">// 绑定hash监听事件</span>\n        <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">\'hashchange\'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n            <span class="hljs-keyword">this</span>.load()\n        })\n    }\n\n    <span class="hljs-comment">// 注册路由</span>\n    register = <span class="hljs-function">(<span class="hljs-params">hash, cb</span>) =&gt;</span> {\n        <span class="hljs-keyword">this</span>.routers[hash] = cb;\n    }\n\n    <span class="hljs-comment">// 注册首页路由</span>\n    registerIndex = <span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> {\n        <span class="hljs-keyword">this</span>.routers[<span class="hljs-string">\'index\'</span>] = cb;\n    }\n\n    load = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n        <span class="hljs-keyword">let</span> hash = location.hash.slice(<span class="hljs-number">1</span>);\n        <span class="hljs-keyword">let</span> handle;\n\n        <span class="hljs-keyword">if</span> (!hash) {  <span class="hljs-comment">// 说明是主页</span>\n            handle = <span class="hljs-keyword">this</span>.routers.index;\n        } <span class="hljs-keyword">else</span> {\n            handle = <span class="hljs-keyword">this</span>.routers[hash];\n        }\n\n        handle();\n    }\n\n}</code></pre>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"nav"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#/page1"</span>&gt;</span>page1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#/page2"</span>&gt;</span>page2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#/page3"</span>&gt;</span>page3<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#/page4"</span>&gt;</span>page4<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#/page5"</span>&gt;</span>page5<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"container"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>\n<p><strong>使用</strong></p>\n<pre><code class="language-js"><span class="hljs-keyword">let</span> router = <span class="hljs-keyword">new</span> HashRouter();\n<span class="hljs-keyword">let</span> container = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">\'container\'</span>);\n\n<span class="hljs-comment">//注册首页回调函数</span>\nrouter.registerIndex(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span> container.innerHTML = <span class="hljs-string">\'我是首页\'</span>);\n\n<span class="hljs-comment">//注册其他视图回到函数</span>\nrouter.register(<span class="hljs-string">\'/page1\'</span>,<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span> container.innerHTML = <span class="hljs-string">\'我是page1\'</span>);\nrouter.register(<span class="hljs-string">\'/page2\'</span>,<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span> container.innerHTML = <span class="hljs-string">\'我是page2\'</span>);\nrouter.register(<span class="hljs-string">\'/page3\'</span>,<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span> container.innerHTML = <span class="hljs-string">\'我是page3\'</span>);\n\n<span class="hljs-comment">// 加载页面</span>\nrouter.load();</code></pre>\n<h3 id="hash模式-1">hash模式</h3>\n<p>在 HTML5 的规范中，history 新增了以下几个 API：</p>\n<pre><code class="language-js"><span class="hljs-keyword">history</span>.pushState<span class="hljs-params">()</span>;         <span class="hljs-string">//</span> 添加新的状态到历史状态栈\n<span class="hljs-keyword">history</span>.replaceState<span class="hljs-params">()</span>;      <span class="hljs-string">//</span> 用新的状态代替当前状态\n<span class="hljs-keyword">history</span>.state                <span class="hljs-string">//</span> 返回当前状态对象</code></pre>\n<p>由于 history.pushState() 和 history.replaceState() 可以改变 url 同时，不会刷新页面，所以在 HTML5 中的 histroy 具备了实现前端路由的能力</p>\n<ul>\n<li>hash 路由通过监听haschange事件进行跳转路由的。</li>\n<li>history的改变并不会触发任何事件，所以我们无法直接监听 history 的改变而做出相应的改变.。</li>\n</ul>\n<p>所以我们换个思路，将这些方式进行拦截，变相的监听history的变化。</p>\n<blockquote>\n<ol>\n<li>点击浏览器的前进或后退按钮</li>\n<li>点击a标签</li>\n<li>在 JS 代码中触发 history.pushState 函数</li>\n<li>在 JS 代码中触发 history.replaceState 函数</li>\n</ol>\n</blockquote>\n<ul>\n<li><p><strong><em>手动实现history路由</em></strong></p>\n<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HistoryRouter</span> </span>{\n  <span class="hljs-keyword">constructor</span>(){\n      <span class="hljs-keyword">this</span>.routers = {};\n      <span class="hljs-keyword">this</span>.listenPopState();\n      <span class="hljs-keyword">this</span>.listenLink();\n  }\n\n  <span class="hljs-comment">// 全局监听a标签</span>\n  listenLink = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n      <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">\'click\'</span>, (e) =&gt; {\n          <span class="hljs-keyword">let</span> target = e.target;\n\n          <span class="hljs-keyword">if</span> (target.tagName.toUpperCase() === <span class="hljs-string">\'A\'</span> &amp;&amp; target.getAttribute(<span class="hljs-string">\'href\'</span>)) {\n              e.preventDefault();  <span class="hljs-comment">// 组织默认行为</span>\n              <span class="hljs-keyword">this</span>.assign(target.getAttribute(<span class="hljs-string">\'href\'</span>));\n          }\n      })\n  }\n\n  <span class="hljs-comment">//用于首次进入页面时调用</span>\n  load(){\n      <span class="hljs-keyword">let</span> path = location.pathname;\n      <span class="hljs-keyword">this</span>.dealPathHandler(path)\n  }\n\n  <span class="hljs-comment">//用于注册每个视图</span>\n  register(path,callback = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{}){\n      <span class="hljs-keyword">this</span>.routers[path] = callback;\n  }\n  <span class="hljs-comment">//用于注册首页</span>\n  registerIndex(callback = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{}){\n      <span class="hljs-keyword">this</span>.routers[<span class="hljs-string">\'/\'</span>] = callback;\n  }\n  <span class="hljs-comment">//用于处理视图未找到的情况</span>\n  registerNotFound(callback = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{}){\n      <span class="hljs-keyword">this</span>.routers[<span class="hljs-string">\'404\'</span>] = callback;\n  }\n\n  <span class="hljs-comment">// 跳转到path</span>\n  assign = <span class="hljs-function">(<span class="hljs-params">path</span>) =&gt;</span> {\n      history.pushState({path}, <span class="hljs-literal">null</span>, path);\n      <span class="hljs-keyword">this</span>.dealPathHandler(path);\n  }\n\n   <span class="hljs-comment">//替换为path</span>\n  replace(path){\n      history.replaceState({path},<span class="hljs-literal">null</span>,path);\n      <span class="hljs-keyword">this</span>.dealPathHandler(path)\n  }\n\n  <span class="hljs-comment">//监听popstate</span>\n  listenPopState = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n      <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">\'popstate\'</span>, (e) =&gt; {\n          <span class="hljs-keyword">let</span> state = e.state || {};\n          <span class="hljs-keyword">let</span> path = state.path || <span class="hljs-string">\'\'</span>;\n          <span class="hljs-keyword">this</span>.dealPathHandler(path);\n      })\n  }\n\n  <span class="hljs-comment">// 处理path跳转页面</span>\n  dealPathHandler = <span class="hljs-function">(<span class="hljs-params">path</span>) =&gt;</span> {\n      <span class="hljs-keyword">let</span> handle;\n      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.routers[path]) {  <span class="hljs-comment">// 没有对应path</span>\n          handle = <span class="hljs-keyword">this</span>.routers[<span class="hljs-string">\'404\'</span>] || <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{};\n      } <span class="hljs-keyword">else</span> {\n          <span class="hljs-comment">// 对应path</span>\n          handle = <span class="hljs-keyword">this</span>.routers[path]\n      }\n\n      handle.call(<span class="hljs-keyword">this</span>);\n\n  }\n}</code></pre>\n</li>\n</ul>\n<p><strong>使用</strong></p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"nav"</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/page1"</span>&gt;</span>page1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/page2"</span>&gt;</span>page2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/page3"</span>&gt;</span>page3<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/page4"</span>&gt;</span>page4<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/page5"</span>&gt;</span>page5<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>\n        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"btn"</span>&gt;</span>page2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"container"</span>&gt;</span>\n\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>\n<pre><code class="language-js">let router = <span class="hljs-keyword">new</span> HistoryRouter();\nlet container = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">\'container\'</span>);\n\n<span class="hljs-regexp">//</span>注册首页回调函数\nrouter.registerIndex(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> container.innerHTML = <span class="hljs-string">\'我是首页\'</span>);\n\n<span class="hljs-regexp">//</span>注册其他视图回到函数\nrouter.register(<span class="hljs-string">\'/page1\'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> container.innerHTML = <span class="hljs-string">\'我是page1\'</span>);\nrouter.register(<span class="hljs-string">\'/page2\'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> container.innerHTML = <span class="hljs-string">\'我是page2\'</span>);\nrouter.register(<span class="hljs-string">\'/page3\'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> container.innerHTML = <span class="hljs-string">\'我是page3\'</span>);\nrouter.register(<span class="hljs-string">\'/page4\'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">\'抛出一个异常\'</span>)\n});\n\n<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">\'btn\'</span>).onclick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> router.assign(<span class="hljs-string">\'/page2\'</span>)\n\n\n<span class="hljs-regexp">//</span>注册未找到对应path值时的回调\nrouter.registerNotFound(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> container.innerHTML = <span class="hljs-string">\'页面未找到\'</span>);\n<span class="hljs-regexp">//</span>注册出现异常时的回调\nrouter.registerError(<span class="hljs-function"><span class="hljs-params">(e)</span> =&gt;</span> container.innerHTML = <span class="hljs-string">\'页面异常，错误消息：&lt;br&gt;\'</span> + e.message);\n<span class="hljs-regexp">//</span>加载页面\nrouter.load();</code></pre>\n<h2 id="hash、history如何抉择">hash、history如何抉择</h2>\n<p>hash 模式相比于 history 模式的优点：</p>\n<ul>\n<li>兼容性更好，可以兼容到IE8</li>\n<li>无需服务端配合处理非单页的url地址</li>\n</ul>\n<p>hash 模式相比于 history 模式的缺点：</p>\n<ul>\n<li>看起来更丑</li>\n<li>会导致锚点功能失效</li>\n<li>相同 hash 值不会触发动作将记录加入到历史栈中，而 pushState 则可以</li>\n</ul>\n'},844:function(s,n,a){"use strict";a.r(n),n.default='<h2 id="一、变量的声明">一、变量的声明</h2>\n<pre><code class="language-css"><span class="hljs-selector-pseudo">:root</span> {\n  <span class="hljs-attribute">--w</span>: <span class="hljs-number">100px</span>; <span class="hljs-comment">/* 全局变量 */</span>\n}</code></pre>\n<h3 id="变量作用域">变量作用域</h3>\n<blockquote>\n<p>同一个 CSS 变量，可以在多个选择器内声明。读取的时候，<strong>优先级</strong>最高的声明生效。这与 CSS 的<strong>&quot;层叠&quot;</strong>（cascade）规则是一致的。</p>\n</blockquote>\n<p>上面提到了全局变量。</p>\n<pre><code class="language-css"><span class="hljs-selector-class">.container</span> {\n  <span class="hljs-attribute">--h</span>: <span class="hljs-number">10px</span>;\n  <span class="hljs-comment">/* 局部变量\n      只作用于拥有 .container类名的节点，\n      以及该节点下的所有后辈节点。\n  */</span>\n}</code></pre>\n<h2 id="二、var-函数">二、var() 函数</h2>\n<ul>\n<li>它用于读取变量</li>\n<li>可接受两个参数，第一个参数是作用域内的变量，第二个参数（可选）是第一个参数的默认值。</li>\n<li>变量值只能作为属性值。</li>\n</ul>\n<h2 id="三、变量值的类型">三、变量值的类型</h2>\n<ul>\n<li>类型<ul>\n<li>字符串（&#39;hello world&#39;）不能是带单位带数字。</li>\n<li>数字。</li>\n<li>带单位的数字（1px, 30deg, ...）。</li>\n</ul>\n</li>\n<li>运算规则<ul>\n<li>字符串可以拼接。</li>\n<li>数字运算只能用<code>calc</code>。</li>\n</ul>\n</li>\n</ul>\n<h2 id="五、响应式布局">五、响应式布局</h2>\n<p>变量可用于@media媒体查询。</p>\n<h2 id="六、-与sass、less区别">六、 与sass、less区别</h2>\n<p>变量是动态的，sass、less是静态的，他们没法做到更新变量就刷新布局达到响应式的效果</p>\n<h2 id="七、javascript-操作">七、JavaScript 操作</h2>\n<ul>\n<li>可以通过改变css变量实现动画、主题等；例如<a href="https://esop-fed.github.io/ani-css">ani-css首页的robot</a><h2 id="其他优秀文章">其他优秀文章</h2>\n<a href="https://www.zhangxinxu.com/wordpress/2016/11/css-css3-variables-var/">小tips:了解CSS/CSS3原生变量var</a></li>\n</ul>\n'},845:function(s,n,a){"use strict";a.r(n),n.default='<h2 id="「中高级前端」高性能渲染十万条数据">「中高级前端」高性能渲染十万条数据</h2>\n<blockquote>\n<p>本文探讨：当遇到大量数据时，如何才能在不卡主页面的情况下渲染数据，以及其背后的原理。以下比较了4种不同的方式：</p>\n</blockquote>\n<ol>\n<li>暴力渲染</li>\n<li>setTimeout</li>\n<li>requestAnimationFrame</li>\n<li>DocumentFragment</li>\n</ol>\n<h2 id="一、暴力渲染">一、暴力渲染</h2>\n<pre><code><span class="hljs-comment">// 记录任务开始时间</span>\n<span class="hljs-keyword">let</span> now = <span class="hljs-built_in">Date</span>.now();\n<span class="hljs-comment">// 插入十万条数据</span>\n<span class="hljs-keyword">const</span> total = <span class="hljs-number">100000</span>;\n<span class="hljs-comment">// 获取容器</span>\n<span class="hljs-keyword">let</span> ul = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">\'container\'</span>);\n<span class="hljs-comment">// 将数据插入容器中</span>\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; total; i++) {\n    <span class="hljs-keyword">let</span> li = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">\'li\'</span>);\n    li.innerText = ~~(<span class="hljs-built_in">Math</span>.random() * total)  <span class="hljs-comment">// ~~</span>\n    ul.appendChild(li);\n}\n\n<span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'JS运行时间：\'</span>,<span class="hljs-built_in">Date</span>.now() - now);\nsetTimeout(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'总运行时间：\'</span>,<span class="hljs-built_in">Date</span>.now() - now);\n},<span class="hljs-number">0</span>)\n<span class="hljs-comment">// print: JS运行时间： 187ms</span>\n<span class="hljs-comment">// print: 总运行时间： 2844ms</span></code></pre><blockquote>\n<p>简单说明一下，为何两次console.log的结果时间差异巨大，并且是如何简单来统计JS运行时间和总渲染时间：</p>\n</blockquote>\n<blockquote>\n<p>在 JS 的Event Loop中，当JS引擎所管理的执行栈中的事件以及所有微任务事件全部执行完后，才会触发渲染线程对页面进行渲染</p>\n</blockquote>\n<ul>\n<li>第一个console.log的触发时间是在页面进行渲染之前，此时得到的间隔时间为JS运行所需要的时间</li>\n<li>第二个console.log是放到 setTimeout 中的，它的触发时间是在渲染完成，在下一次Event Loop中执行的</li>\n</ul>\n<p><strong>结果：页面卡顿，是由于同时渲染大量DOM所引起的，所以下面考虑将渲染过程分批进行：</strong></p>\n<h2 id="二、settimeout">二、setTimeout</h2>\n<pre><code><span class="hljs-comment">//需要插入的容器</span>\n<span class="hljs-keyword">let</span> ul = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">\'container\'</span>);\n<span class="hljs-comment">// 插入十万条数据</span>\n<span class="hljs-keyword">let</span> total = <span class="hljs-number">100000</span>;\n<span class="hljs-comment">// 一次插入 20 条</span>\n<span class="hljs-keyword">let</span> once = <span class="hljs-number">20</span>;\n<span class="hljs-comment">//总页数</span>\n<span class="hljs-keyword">let</span> page = total/once\n<span class="hljs-comment">//每条记录的索引</span>\n<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;\n<span class="hljs-comment">//循环加载数据</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loop</span>(<span class="hljs-params">curTotal,curIndex</span>)</span>{\n    <span class="hljs-keyword">if</span>(curTotal &lt;= <span class="hljs-number">0</span>){\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;\n    }\n    <span class="hljs-comment">//每页多少条</span>\n    <span class="hljs-keyword">let</span> pageCount = <span class="hljs-built_in">Math</span>.min(curTotal , once);\n    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{\n        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; pageCount; i++){\n            <span class="hljs-keyword">let</span> li = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">\'li\'</span>);\n            li.innerText = curIndex + i + <span class="hljs-string">\' : \'</span> + ~~(<span class="hljs-built_in">Math</span>.random() * total)\n            ul.appendChild(li)\n        }\n        loop(curTotal - pageCount,curIndex + pageCount)\n    },<span class="hljs-number">0</span>)\n}\nloop(total,index);</code></pre><p><strong>导致结果：渲染加快但是有白屏或闪屏现象</strong></p>\n<h5 id="1、闪屏原因">1、闪屏原因</h5>\n<blockquote>\n<ul>\n<li><strong>FPS</strong>：表示的是每秒钟画面更新次数，是描述帧变化速度的物理量。</li>\n</ul>\n</blockquote>\n<ul>\n<li><strong>FPS为60frame/s</strong>：大多显示器会以每秒60次的频率，不断的更新屏幕上的图像。</li>\n<li><strong>16.7ms</strong>：根据视觉暂留现象，最平滑动画的最佳循环间隔是1000ms/60，约等于16.7ms。</li>\n</ul>\n<h5 id="2、settimeout与闪屏的关系---刷新步调可能会-不一致">2、setTimeout与闪屏的关系 -&gt; 刷新步调可能会 不一致</h5>\n<blockquote>\n<ul>\n<li>setTimeout的执行时间并不是确定的。实际执行时间可能会比其设定的时间晚一些。</li>\n</ul>\n</blockquote>\n<ul>\n<li>刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的刷新频率可能会不同，而setTimeout只能设置一个固定时间间隔，这个时间不一定和屏幕的刷新时间相同。</li>\n</ul>\n<p>以上两种情况都会导致setTimeout的执行步调和屏幕的<strong>刷新步调不一致</strong>。\n在setTimeout中对dom进行操作，必须要等到屏幕下次绘制时才能更新到屏幕上，如果两者步调不一致，就<strong>可能导致中间某一帧的操作被跨越过去</strong>，而直接更新下一帧的元素，从而<strong>导致丢帧现象</strong>。</p>\n<h2 id="三、requestanimationframe（不会产生丢帧现象）">三、requestAnimationFrame（不会产生丢帧现象）</h2>\n<p>requestAnimationFrame是系统来决定回调函数的执行时机。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象。</p>\n<pre><code><span class="hljs-comment">//需要插入的容器</span>\n<span class="hljs-keyword">let</span> ul = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">\'container\'</span>);\n<span class="hljs-comment">// 插入十万条数据</span>\n<span class="hljs-keyword">let</span> total = <span class="hljs-number">100000</span>;\n<span class="hljs-comment">// 一次插入 20 条</span>\n<span class="hljs-keyword">let</span> once = <span class="hljs-number">20</span>;\n<span class="hljs-comment">//总页数</span>\n<span class="hljs-keyword">let</span> page = total/once\n<span class="hljs-comment">//每条记录的索引</span>\n<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;\n<span class="hljs-comment">//循环加载数据</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loop</span>(<span class="hljs-params">curTotal,curIndex</span>)</span>{\n    <span class="hljs-keyword">if</span>(curTotal &lt;= <span class="hljs-number">0</span>){\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;\n    }\n    <span class="hljs-comment">//每页多少条</span>\n    <span class="hljs-keyword">let</span> pageCount = <span class="hljs-built_in">Math</span>.min(curTotal , once);\n    <span class="hljs-built_in">window</span>.requestAnimationFrame(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; pageCount; i++){\n            <span class="hljs-keyword">let</span> li = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">\'li\'</span>);\n            li.innerText = curIndex + i + <span class="hljs-string">\' : \'</span> + ~~(<span class="hljs-built_in">Math</span>.random() * total)\n            ul.appendChild(li)\n        }\n        loop(curTotal - pageCount,curIndex + pageCount)\n    })\n}\nloop(total,index);\n</code></pre><p><strong>结果：很流畅，没有出现闪烁丢帧的现象，但还能再优化</strong></p>\n<h2 id="四、使用-documentfragment">四、使用 DocumentFragment</h2>\n<blockquote>\n<ul>\n<li>DocumentFragment，文档片段接口，它被作为一个轻量版的 Document 使用。DocumentFragments是DOM节点，但并不是    DOM树的一部分，可以认为是存在内存中的，所以将子元素插入到文档片段时不会引起页面回流。可以用于避免回流操作。</li>\n</ul>\n</blockquote>\n<ul>\n<li>可以使用document.createDocumentFragment 方法或者构造函数来创建一个空的 DocumentFragment.</li>\n</ul>\n<pre><code><span class="hljs-comment">//需要插入的容器</span>\n<span class="hljs-keyword">let</span> ul = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">\'container\'</span>);\n<span class="hljs-comment">// 插入十万条数据</span>\n<span class="hljs-keyword">let</span> total = <span class="hljs-number">100000</span>;\n<span class="hljs-comment">// 一次插入 20 条</span>\n<span class="hljs-keyword">let</span> once = <span class="hljs-number">20</span>;\n<span class="hljs-comment">//总页数</span>\n<span class="hljs-keyword">let</span> page = total/once\n<span class="hljs-comment">//每条记录的索引</span>\n<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;\n<span class="hljs-comment">//循环加载数据</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loop</span>(<span class="hljs-params">curTotal,curIndex</span>)</span>{\n    <span class="hljs-keyword">if</span>(curTotal &lt;= <span class="hljs-number">0</span>){\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;\n    }\n    <span class="hljs-comment">//每页多少条</span>\n    <span class="hljs-keyword">let</span> pageCount = <span class="hljs-built_in">Math</span>.min(curTotal , once);\n    <span class="hljs-built_in">window</span>.requestAnimationFrame(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n        <span class="hljs-keyword">let</span> fragment = <span class="hljs-built_in">document</span>.createDocumentFragment();\n        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; pageCount; i++){\n            <span class="hljs-keyword">let</span> li = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">\'li\'</span>);\n            li.innerText = curIndex + i + <span class="hljs-string">\' : \'</span> + ~~(<span class="hljs-built_in">Math</span>.random() * total)\n            fragment.appendChild(li)\n        }\n        ul.appendChild(fragment)\n        loop(curTotal - pageCount,curIndex + pageCount)\n    })\n}\nloop(total,index);</code></pre><h2 id="四、使用-display">四、使用 display</h2>\n<p>可以先将元素脱离文档流、对其修改、在带回文档流，比如 display:none，添加修改完最后 在display: block</p>\n'},846:function(s,n,a){"use strict";a.r(n),n.default='<h1 id="diff算法概述">diff算法概述</h1>\n<h3 id="1传统的diff算法为何是n3">1.传统的diff算法为何是n^3</h3>\n<p>有新旧两个节点beforeNode, afterNode</p>\n<ul>\n<li>取新旧两个节点的最大长度来遍历对比(<strong>for循环n^2</strong>)<pre><code class="language-javascript"><span class="hljs-keyword">let</span> result = []; <span class="hljs-comment">// 记录节点需要进行的操作</span>\n<span class="hljs-keyword">const</span> diffNodes = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">beforeNode, afterNode</span>) </span>{\n  <span class="hljs-comment">// 获取较大节点树的长度</span>\n  <span class="hljs-keyword">let</span> count = <span class="hljs-built_in">Math</span>.max(beforeNode.children.length, afterNode.children.length);\n  <span class="hljs-comment">// 循环遍历进行新旧每个节点的对比(n^2)</span>\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) {\n      <span class="hljs-keyword">const</span> beforeTag = beforeLeaf.children[i];\n      <span class="hljs-keyword">const</span> afterTag = afterLeaf.children[i];\n       ...\n  }\n  <span class="hljs-keyword">return</span> result;\n}</code></pre>\n</li>\n</ul>\n<ul>\n<li>分析情况做出相应操作</li>\n</ul>\n<ol>\n<li>第一种情况<pre><code class="language-javascript"><span class="hljs-selector-tag">if</span> (beforeNode === undefined) {\n   <span class="hljs-selector-tag">result</span><span class="hljs-selector-class">.push</span>({ <span class="hljs-attribute">type</span>: <span class="hljs-string">"add"</span>, <span class="hljs-attribute">el</span>: afterTag }); <span class="hljs-comment">// 旧的位置没有</span>\n}</code></pre>\n</li>\n<li>第二种情况<pre><code class="language-javascript"><span class="hljs-selector-tag">if</span> (afterNode === undefined) {\n   <span class="hljs-selector-tag">result</span><span class="hljs-selector-class">.push</span>({ <span class="hljs-attribute">type</span>: <span class="hljs-string">"remove"</span>, <span class="hljs-attribute">el</span>: beforeTag }); <span class="hljs-comment">// 旧的位置没有</span>\n}</code></pre>\n</li>\n<li>第三种情况<pre><code class="language-javascript"><span class="hljs-selector-tag">if</span> (beforeTag.tagName !== afterTag.tagName) {\n   <span class="hljs-comment">// 节点名改变时，删除 beforeTag 节点，添加 afterTag 节点</span>\n   <span class="hljs-selector-tag">result</span><span class="hljs-selector-class">.push</span>({ <span class="hljs-attribute">type</span>: <span class="hljs-string">"remove"</span>, <span class="hljs-attribute">element</span>: beforeTag });\n   <span class="hljs-selector-tag">result</span><span class="hljs-selector-class">.push</span>({ <span class="hljs-attribute">type</span>: <span class="hljs-string">"add"</span>, <span class="hljs-attribute">element</span>: afterTag });\n}</code></pre>\n</li>\n<li>第四种情况<pre><code class="language-javascript"><span class="hljs-selector-tag">else</span> <span class="hljs-selector-tag">if</span> (beforeTag.innerHTML !== afterTag.innerHTML) {\n   <span class="hljs-selector-tag">if</span> (beforeTag.children.length === <span class="hljs-number">0</span>) {\n       <span class="hljs-selector-tag">result</span><span class="hljs-selector-class">.push</span>({\n           <span class="hljs-attribute">type</span>: <span class="hljs-string">"changed"</span>,\n           <span class="hljs-attribute">beforeElement</span>: beforeTag,\n           <span class="hljs-attribute">afterElement</span>: afterTag,\n           <span class="hljs-attribute">html</span>: afterTag.innerHTML\n       });\n   } else {\n       <span class="hljs-comment">// 递归比较</span>\n       <span class="hljs-selector-tag">diffNodes</span>(beforeTag, afterTag);\n   }\n}</code></pre>\n</li>\n</ol>\n<ul>\n<li><p>进行最后的最小操作数计算(<strong>此时操作上升为n^3</strong>)，我们大致简单理解一下，真实算法有兴趣可以自行查询<a href="http://vldb.org/pvldb/vol5/p334_mateuszpawlik_vldb2012.pdf">Trees Edit Distance</a></p>\n<blockquote>\n<p><a href="https://www.zhihu.com/question/66851503/answer/246766239">掘金react的diff 从O(n^3)到 O(n) </a></p>\n</blockquote>\n<p>  最小操作就是计算更新为新的dom时所需要的最少步骤</p>\n<pre><code>Prev                               Last\n        <span class="hljs-keyword">div</span>                             <span class="hljs-keyword">div</span> \n       / \\                             / \\ \n     ul   p     ====&gt;            p   p\n    /  \\                             |    \n  li   li                           <span class="hljs-keyword">text</span> \n  |\n <span class="hljs-keyword">text</span>\n最优方式可以删除Prev的ul节点，再插入一个新的P节点，最后再p节点下插入<span class="hljs-keyword">text</span>。总共三步。</code></pre></li>\n</ul>\n<hr>\n<h3 id="2-优化的diff算法n">2. 优化的diff算法n</h3>\n<blockquote>\n<p><a href="https://www.jianshu.com/p/398e63dc1969">简书传统diff、react优化diff、vue优化diff</a><br><a href="https://blog.csdn.net/sexy_squirrel/article/details/79801940">react的diff</a>\n<a href="https://www.cnblogs.com/wind-lanyan/p/9061684.html">vue的diff</a></p>\n</blockquote>\n<p><strong>React &amp; Vue</strong></p>\n<ul>\n<li>两者都采用的是同级比较，且通过唯一的key值来比对。只需要对比同一key的dom，如果不同就不需要继续考虑子级别dom，所以复杂度为n。</li>\n</ul>\n<ul>\n<li><p>React短板在于ABCD=&gt;DABC, 遵从lastIndex比对原则，newIndex &lt; lastIndex则移动，否则不变，ABC会分别移动到D的后面，而不是D移动 </p>\n<p>到最前面，这就是性能浪费。</p>\n<blockquote>\n<p>1&gt; 当前lastIndex为0，newVNode第一个为D，即nextIndex = 0，找到D在oldVNode中索引为3，即prevIndex = 3，prevIndex &gt; lastIndex 不移动, nextIndex++，lastIndex = Math.max(lastIndex, prevIndex) = 3<br> 2&gt; nextIndex = 1, lastIndex为3，第二个为A，prevIndex = 0，prevIndex &lt; lastIndex, 移动，nextIndex++, lastIndex = Math.max(3, 0) = 3<br> 3&gt; ...如此循环，直到循环结束<br> 4&gt; 判断oldVNode中并没有newVNode中没有的节点，不执行remove操作, 到此ABC都进行了dom操作</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>Vue采用了新旧虚拟dom的首尾对比阶段。即先进行新旧两种dom首尾四种比对，如果满足就进行操作。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较。</p>\n<p>1&gt; 遍历生成虚拟dom</p>\n<pre><code class="language-javascript">  <span class="hljs-comment">// body下的 &lt;div id="v" class="classA"&gt;&lt;div&gt; 对应的 oldVnode 就是</span>\n  {\n    <span class="hljs-attribute">el</span>:  div  <span class="hljs-comment">//对真实的节点的引用，本例中就是document.querySelector(\'#id.classA\')</span>\n    <span class="hljs-attribute">tagName</span>: <span class="hljs-string">\'DIV\'</span>,   <span class="hljs-comment">//节点的标签</span>\n    <span class="hljs-attribute">sel</span>: <span class="hljs-string">\'div#v.classA\'</span>  <span class="hljs-comment">//节点的选择器</span>\n    <span class="hljs-attribute">data</span>: null,       <span class="hljs-comment">// 一个存储节点属性的对象，对应节点的el[prop]属性，例如onclick , style</span>\n    <span class="hljs-attribute">children</span>: [], <span class="hljs-comment">//存储子节点的数组，每个子节点也是vnode结构</span>\n    <span class="hljs-attribute">text</span>: null,    <span class="hljs-comment">//如果是文本节点，对应文本节点的textContent，否则为null</span>\n  }</code></pre>\n<p>2&gt; 首先进行patch方法比对新旧Vnode，执行sameVnode方法比较，也就是比较是不是同一类型且属性不变\n3&gt; sameVnode不通过就执行删除添加操作，通过执行patchVnode方法，oldVnode === vnode引用相同就视为不变，如果不同再比较text，text不同触发setTextContent 修改text，text相同只有oldVnode有子节点就执行remove操作，如果只有newVnode有子节点就执行add操作，都不满足就执行updateChildren方法，对子节点比对，这是核心diff\n4&gt; oldStart，oldEnd，newStart，newEnd首尾两两比较，当oldStartIdx &gt; oldEndIdx &amp;&amp; newStartIdx &gt; newEndIdx时就中断比较。</p>\n<blockquote>\n<p>vue diff ABCD =&gt; DBA 从两侧向中间比对</p>\n<ol>\n<li>oldStart = A, oldEnd = D, newStart = D, newEnd = A. oldStart匹配到newEnd，真实dom中A移动最后，\noldEnd匹配到newStart, 真实dom中D移动到最前面</li>\n<li>oldStart = B, oldEnd = C, newStart = B, newEnd = B, oldStart匹配到newStart，真实dom中B不变，</li>\n<li>newStartIdx++ 0-&gt;1-&gt;2，newEndIdx-- 为3-&gt;2-&gt;1, oldStartIdx++ 为0-&gt;1-&gt;2，oldEndIdx-- 为2-&gt;1-&gt;0，newStartInx &gt; newEndIdx, 新的Vnode遍历结束，终止diff</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li>Vue在比对新旧节点时，如果两个节点是同一类型，但是仅仅只是属性发生变化，比如className，Vue会执行删除当前节点\n添加新的节点的操作，而React只会更新相关的属性<pre><code class="language-javascript"><span class="hljs-comment">// vue</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sameVnode</span><span class="hljs-params">(oldVnode, vnode)</span></span>{\n  <span class="hljs-comment">//两节点key值相同，并且sel属性值相同，即认为两节点属同一类型，可进行下一步比较</span>\n  <span class="hljs-keyword">return</span> vnode.key === oldVnode.key &amp;&amp; vnode.sel === oldVnode.sel\n}</code></pre>\n</li>\n</ul>\n<p><strong>Key的重要性</strong>  </p>\n<p> key是实现diff优化操作的关键，假如没有key。ABCD=&gt;DCBA 过程中，如果简单判断A和D，B和C，C和B，D和A比对后，就会进行四次dom替换，如果彻底比对就需要n^3复杂度。如果有key，只需要进行同key值判断就可以了。</p>\n<hr>\n<p>End</p>\n'},847:function(s,n,a){"use strict";a.r(n),n.default='<h2 id="函数组合包含在函数式编程范畴中，就是一种将已被分解的简单任务组合成复杂任务的过程">函数组合包含在函数式编程范畴中，就是一种将已被分解的简单任务组合成复杂任务的过程</h2>\n<h3 id="一、什么是组合">一、<strong><em>什么是组合</em></strong></h3>\n<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compose</span><span class="hljs-params">(f, g)</span><span class="hljs-comment">{\n    return function(x) {\n        return  f(g(x))\n    }</span>\n}\n// <span class="hljs-title">compose</span><span class="hljs-params">(f,g)</span><span class="hljs-params">(x)</span> === <span class="hljs-title">f</span><span class="hljs-params">(g(x)</span>)\n// <span class="hljs-title">compose</span><span class="hljs-params">(f,g,m)</span><span class="hljs-params">(x)</span> === <span class="hljs-title">f</span><span class="hljs-params">(g(m(x)</span>))\n// <span class="hljs-title">compose</span><span class="hljs-params">(f,g,m)</span><span class="hljs-params">(x)</span> === <span class="hljs-title">f</span><span class="hljs-params">(g(m(x)</span>))\n// <span class="hljs-title">compose</span><span class="hljs-params">(f,g,m,n)</span><span class="hljs-params">(x)</span> === <span class="hljs-title">f</span><span class="hljs-params">(g(m(n(x)</span>)))\n//···\n</span></code></pre>\n<p><code>compose</code>函数，接受若干个函数作为参数；每个函数执行后的输出作为下一个函数的输入；直到最后一个函数执行完毕</p>\n<h3 id="二、应用compose函数">二、<strong><em>应用compose函数</em></strong></h3>\n<p>假如一个需求，对一个字符串转换为 四舍五入 的数字。</p>\n<ul>\n<li><strong>常规实现</strong>：</li>\n</ul>\n<pre><code class="language-js"><span class="hljs-keyword">let</span> n = \'<span class="hljs-number">3.56</span>\';\n<span class="hljs-keyword">let</span> data = parse<span class="hljs-constructor">Float(<span class="hljs-params">n</span>)</span>;\n<span class="hljs-keyword">let</span> result = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>round(data); <span class="hljs-comment">// =&gt;4 最终结果</span></code></pre>\n<ul>\n<li><strong>compose实现</strong>：</li>\n</ul>\n<pre><code class="language-js"><span class="hljs-keyword">let</span> n = <span class="hljs-string">\'3.56\'</span>;\n<span class="hljs-keyword">let</span> <span class="hljs-built_in">number</span> = compose(<span class="hljs-built_in">Math</span>.round,<span class="hljs-built_in">parseFloat</span>);\n<span class="hljs-keyword">let</span> result = <span class="hljs-built_in">number</span>(n); <span class="hljs-comment">// =&gt;4 最终结果</span></code></pre>\n<blockquote>\n<p>这个组合的过程就是函数式组合！我们将两个函数组合一起便能构造出新的函数</p>\n</blockquote>\n<h3 id="三、实现组合">三、<strong><em>实现组合</em></strong></h3>\n<blockquote>\n<p>概括来说，就是接收若干个函数作为参数，返回一个新函数。新函数执行时，按照 <span style="color: red">由右向左</span> 的顺序依次执行传入compose中的函数，每个函数的执行结果作为为下一个函数的输入，直至最后一个函数的输出作为最终的输出结果</p>\n</blockquote>\n<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compose</span><span class="hljs-params">(<span class="hljs-rest_arg">...fns</span>)</span></span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span></span>{\n        <span class="hljs-keyword">return</span> fns.reduceRight(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arg,fn)</span></span>{\n            <span class="hljs-keyword">return</span> fn(arg);\n        },x)\n    }\n}\n接受的参数是不确定的，是一个数组，然后由右向左执行函数</code></pre>\n<h3 id="四、实现管道">四、<strong><em>实现管道</em></strong></h3>\n<blockquote>\n<p>从左至右处理数据流的过程称之为管道(pipeline)! <br/>\n即管道的执行顺序是<span style="color: red">由左向右</span></p>\n</blockquote>\n<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pipe</span><span class="hljs-params">(<span class="hljs-rest_arg">...fns</span>)</span></span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span></span>{\n        <span class="hljs-keyword">return</span> fns.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arg,fn)</span></span>{\n            <span class="hljs-keyword">return</span> fn(arg);\n        },x)\n    }\n}</code></pre>\n'},849:function(s,n,a){s.exports={"blink-smooth":"blink-smooth-34C_Up9D"}},86:function(s,n,a){s.exports=a(36)(41)}});
//# sourceMappingURL=app_6b3343a8.js.map